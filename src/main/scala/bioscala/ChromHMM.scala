package ChromHMM

import os._
import SZUtils.{readHead, readTable}
import GRange.GenomicRange
import Bed.BedElement4

case class ChromHMMState(name: String, g: GenomicRange) {

  /**
    * Format: chr:start-end_name
    *
    * @return
    */
  override def toString: String = {
    s"${g.toString()}_${name}"
  }
}

object ChromHMMState {
  /**
    * From format: chr:start-end_name to ChromHMMState.
    *
    * @param a
    * @return
    */
  def fromStr(a: String): ChromHMMState = {
    val a2 = a.split("_")
    val g = GenomicRange.fromUCSCStr(a2(0))
    val name = a2(1)
    new ChromHMMState(name, g)
  }
}

/**
  * Given a peak with its genomic range, add chrommHMM state info. The
  * chromHMM states' genomic ranges are within the peak range.
  *
  * @param p
  * @param a
  */
case class PeakChromHMMStateAnnot(p: GenomicRange, a: Vector[ChromHMMState]) {

  /**
    * Format: chr1:0-100,chr1:0-10_s1;chr1:10-20_s2
    *
    * @return
    */
  override def toString: String = {
    val r1 = s"${p.toString()}"
    val r2 = a.map(x => x.toString()).mkString(";")
    s"${r1},${r2}"
  }

  def getMaxCovChromHMMState: ChromHMMState = {
    a.maxBy(x => x.g.endTo - x.g.startFrom)
  }

  /**
    * Annot peak by it's center (i.e., summit)
    * If no states mapped to center, then "ND".
    * If multiple states (rare, should not happen ideally),
    *  - take the first one.
    *  - it may happend if startFrom and endTo ocassionly have different
    *    states, but this should not happen when defining the overlap for
    *    single base pair.
    * @return
    */
  def annotCenter: String = {
    val c = p.getMidGR()
    val i = a.zipWithIndex.filter( _._1.g.isOverlap(c)).map(_._2)
    if (i.nonEmpty) {
      a(i(0)).name
    } else {
       "ND"
    }
  }
} // end of case class PeakChromHMMStateAnnot

case class DenseBedElement(g: GenomicRange, name: String, score: Double,
  strand: String, startFrom: Int, endTo: Int, rgb: String)

/**
 * Load DenseBedElement from the dense bed generated by ChromHMM.
 *
 * @param f
 *   filename
 * @return
 *   Head of the file and List of the elements.
 */
def loadDenseBed(f: String): (String, Seq[DenseBedElement]) = {
  val h = readHead(f)
  val content = os.read.lines.stream(os.Path(f))
    .drop(1)
    .map(x => x.strip().split("\t"))
    .map(x => {
      new DenseBedElement(
          new GenomicRange(chrom = x(0), startFrom = x(1).toInt,
              endTo = x(2).toInt),
          name = x(3),
          score = x(4).toDouble,
          strand = x(5),
          startFrom = x(6).toInt,
          endTo = x(7).toInt,
          rgb = x(8)
      )
    }).toSeq
  (h, content)
}

/**
  * Read annotations from densebed file generated by ChromHMM.
  *
  * @param fnm
  * @return Vector of BedElement4 objects.
  */
def readAnnotFromDenseBed(fnm: String): Vector[BedElement4] = {
  os.read.lines.stream(os.Path(fnm))
    .slice(1, Int.MaxValue)
    .map(x => {
      val y = x.split("\t")
      new BedElement4(
        new GenomicRange(y(0), y(1).toInt, y(2).toInt),
        name = y(3)
      )
    }).toVector
}

case class SegmentElement(g: GenomicRange, name: String)

/**
 * Load Segments.bed generated by ChromHMM
 *
 * @param f
 * @return
 */
def loadSegmentBed(f: String): Vector[SegmentElement] = {
  readTable(f, sep = "\t", head = false)
    .map(x =>
      new SegmentElement(
          g = new GenomicRange(chrom = x(0), startFrom = x(1).toInt,
              endTo = x(2).toInt),
          name = x(3)
      ))
    .toVector
}
